g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
edge.width = 2,
layout = layout_with_fr
)
library(igraph)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "lobby", "patient", "sell", "doctor", "lobby", "doctor", "discuss",
"insurance agent", "sell", "insurance agent", "B5", "hospital", "discuss", "hospital", "care", "CDC", "B5", "CDC", "B2")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
edge.width = 2,
layout = layout_with_fr
)
library(igraph)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "lobby", "patient", "sell", "doctor", "lobby", "doctor", "discuss",
"insurance agent", "sell", "insurance agent", "B5", "hospital", "B4", "hospital", "care", "CDC", "B5", "CDC", "B2")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
edge.width = 2,
layout = layout_with_fr
)
library(igraph)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "lobby", "patient", "sell", "doctor", "lobby", "doctor", "B4",
"insurance agent", "sell", "insurance agent", "B5", "hospital", "B4", "hospital", "care", "CDC", "B5", "CDC", "B2")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
edge.width = 2,
layout = layout_with_fr
)
library(igraph)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby", "argue")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "lobby", "patient", "sell", "doctor", "lobby", "doctor", "discuss",
"insurance agent", "sell", "insurance agent", "argue", "hospital", "discuss", "hospital", "care", "CDC", "argue", "CDC", "B2")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
edge.width = 2,
layout = layout_with_fr
)
library(igraph)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "B1", "patient", "B2", "patient", "B3", "doctor", "B2", "doctor", "B4",
"insurance agent", "B3", "insurance agent", "B5", "hospital", "B4", "hospital", "B1", "CDC", "B5", "CDC", "B2")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
edge.width = 2,
layout = layout_with_fr
)
library(igraph)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "diagnose", "patient", "sell", "doctor", "diagnose", "doctor", "discuss",
"insurance agent", "sell", "insurance agent", "lobby", "hospital", "discuss", "hospital", "care", "CDC",
"lobby", "CDC", "diagnose")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
edge.width = 2,
layout = layout_with_fr
)
library(igraph)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "diagnose", "patient", "sell", "doctor", "diagnose", "doctor", "discuss",
"insurance agent", "sell", "insurance agent", "lobby", "hospital", "discuss", "hospital", "care", "CDC",
"lobby", "CDC", "diagnose")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
vertex.label.color = "black",
edge.width = 2,
layout = layout_with_fr
)
library(igraph)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "diagnose", "patient", "sell", "doctor", "diagnose", "doctor", "discuss",
"insurance agent", "sell", "insurance agent", "lobby", "hospital", "discuss", "hospital", "care", "CDC",
"lobby", "CDC", "diagnose")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
vertex.label.color = "black",
edge.width = 2,
vertex.label.dist = 2,
layout = layout_with_fr
)
library(igraph)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "diagnose", "patient", "sell", "doctor", "diagnose", "doctor", "discuss",
"insurance agent", "sell", "insurance agent", "lobby", "hospital", "discuss", "hospital", "care", "CDC",
"lobby", "CDC", "diagnose")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
vertex.label.color = "black",
edge.width = 2,
layout = layout_with_fr
)
library(igraph)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "diagnose", "patient", "sell", "doctor", "diagnose", "doctor", "discuss",
"insurance agent", "sell", "insurance agent", "lobby", "hospital", "discuss", "hospital", "care", "CDC",
"lobby", "CDC", "diagnose")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label.cex = 0.8,
vertex.label.color = "black",
edge.width = 2,
layout = layout_with_fr,
vertex.frame.color = NA
)
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC", "TikTok")  # First type of nodes
set2 <- c("discuss", "sell", "diagnose", "care", "lobby")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "diagnose", "patient", "sell", "doctor", "diagnose", "doctor", "discuss",
"insurance agent", "sell", "insurance agent", "lobby", "hospital", "discuss", "hospital", "care", "CDC",
"lobby", "CDC", "diagnose", "TikTok", "diagnose")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Set custom labels for nodes
V(g)$label <- V(g)$name
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label = V(g)$label,
vertex.label.cex = 0.8,
vertex.label.color = "black",
edge.width = 2,
layout = layout_with_fr,
vertex.frame.color = NA  # Remove black edge around nodes
)
# Create a bipartite graph
# Define two sets of nodes
set1 <- c("patient", "doctor", "insurance agent", "hospital", "CDC")  # First type of nodes
set2 <- c("discuss", "sell", "care", "lobby", "negotiate")  # Second type of nodes
# Create edges between the two sets of nodes
edges <- c("patient", "care", "patient", "sell", "doctor", "discuss",
"insurance agent", "sell", "insurance agent", "lobby", "hospital", "discuss", "hospital", "care", "CDC",
"lobby", "patient", "negotiate", "doctor", "negotiate")
# Create the graph
g <- graph(edges, directed = FALSE)
# Set node attributes for bipartite graph
V(g)$type <- ifelse(V(g)$name %in% set1, TRUE, FALSE)  # Logical values for bipartite types
# Assign colors based on node type
V(g)$color <- ifelse(V(g)$type, "lightblue", "pink")
# Set custom labels for nodes
V(g)$label <- V(g)$name
# Plot the graph
plot(
g,
vertex.color = V(g)$color,
vertex.size = 20,
vertex.label = V(g)$label,
vertex.label.cex = 0.8,
vertex.label.color = "black",
edge.width = 2,
layout = layout_with_fr,
vertex.frame.color = NA  # Remove black edge around nodes
)
runApp('inst/apps/ideanetViz')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
install.packages("future")
install.packages("promises")
shiny::runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
library(promises)
library(future)
plan(multisession)
print("Starting future...")
future({
Sys.sleep(2)  # Simulate long computation
42
}) %...>% {
print(paste("Future result:", .))
} %...!% {
print(paste("Error in future:", .))
}
runApp('~/Documents/Life stuff/xmas2024/harold_app')
library(shiny)
library(promises)
library(future)
plan(multisession)  # Enable asynchronous processing
# Simulated Async Function
simulate_long_computation <- function(input) {
Sys.sleep(2)  # Simulate a delay
paste("Processed response for:", input)
}
# UI
ui <- fluidPage(
titlePanel("Simplified Async Shiny App"),
textInput("user_input", "Enter your question:"),
actionButton("submit", "Submit"),
textOutput("response")
)
# Server
server <- function(input, output, session) {
result <- reactiveVal("")  # Store the result
observeEvent(input$submit, {
req(input$user_input)  # Ensure input is valid
question <- input$user_input
# Debugging: Confirm input capture
print(paste("Input captured:", question))
# Trigger async computation
future({
print("Future started")  # Debugging: Confirm future starts
simulate_long_computation(question)
}) %...>% {
print("Future resolved")  # Debugging: Confirm future resolves
result(.)  # Store the result
} %...!% {
print("Error in future chain")  # Debugging: Handle promise errors
result("Error occurred.")
}
})
# Render the result
output$response <- renderText({
result()
})
}
# Run the app
shinyApp(ui, server)
library(shiny)
library(promises)
library(future)
plan(multisession)  # Enable asynchronous processing
# Simulated Async Function
get_chatgpt_response <- function(question) {
tryCatch({
response <- openai::create_chat_completion(
model = "o1-preview",
messages = list(
list(role = "user", content = paste(
"Write in the voice of an academic specialized in etymology. First, translate the following sentence into any language. Do not translate to Latin or ancient Greek, and focus on less well-known languages. Then, provide one interesting etymological fact connecting the original sentence and the translation. Keep it under 5 sentences, and do not give introductions such as 'a fact connecting the two sentences..' or similar.",
question
))
)
)
return(response$choices$message.content[1])
}, error = function(e) {
# Return a clear error message
paste("Error during API call:", e$message)
})
}
# UI
ui <- fluidPage(
titlePanel("Simplified Async Shiny App"),
textInput("user_input", "Enter your question:"),
actionButton("submit", "Submit"),
textOutput("response")
)
# Server
server <- function(input, output, session) {
result <- reactiveVal("")  # Store the result
observeEvent(input$submit, {
req(input$user_input)  # Ensure input is valid
question <- input$user_input
# Debugging: Confirm input capture
print(paste("Input captured:", question))
# Trigger async computation
future({
print("Future started")  # Debugging: Confirm future starts
simulate_long_computation(question)
}) %...>% {
print("Future resolved")  # Debugging: Confirm future resolves
result(.)  # Store the result
} %...!% {
print("Error in future chain")  # Debugging: Handle promise errors
result("Error occurred.")
}
})
# Render the result
output$response <- renderText({
result()
})
}
# Run the app
shinyApp(ui, server)
library(shiny)
library(promises)
library(future)
plan(multisession)  # Enable asynchronous processing
# Simulated Async Function
get_chatgpt_response <- function(question) {
tryCatch({
response <- openai::create_chat_completion(
model = "o1-preview",
messages = list(
list(role = "user", content = paste(
"Write in the voice of an academic specialized in etymology. First, translate the following sentence into any language. Do not translate to Latin or ancient Greek, and focus on less well-known languages. Then, provide one interesting etymological fact connecting the original sentence and the translation. Keep it under 5 sentences, and do not give introductions such as 'a fact connecting the two sentences..' or similar.",
question
))
)
)
return(response$choices$message.content[1])
}, error = function(e) {
# Return a clear error message
paste("Error during API call:", e$message)
})
}
# UI
ui <- fluidPage(
titlePanel("Simplified Async Shiny App"),
textInput("user_input", "Enter your question:"),
actionButton("submit", "Submit"),
textOutput("response")
)
# Server
server <- function(input, output, session) {
result <- reactiveVal("")  # Store the result
observeEvent(input$submit, {
req(input$user_input)  # Ensure input is valid
question <- input$user_input
# Debugging: Confirm input capture
print(paste("Input captured:", question))
# Trigger async computation
future({
print("Future started")  # Debugging: Confirm future starts
get_chatgpt_response(question)
}) %...>% {
print("Future resolved")  # Debugging: Confirm future resolves
result(.)  # Store the result
} %...!% {
print("Error in future chain")  # Debugging: Handle promise errors
result("Error occurred.")
}
})
# Render the result
output$response <- renderText({
result()
})
}
# Run the app
shinyApp(ui, server)
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
runApp('~/Documents/Life stuff/xmas2024/harold_app')
