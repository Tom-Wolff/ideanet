qap_setup(net, variables = c("house_gender"), methods = c("reduced_category"),
directed = T, additional_vars = NULL)
qap_setup(net, variables = c("house_gender"), methods = c("reduced_category"),
directed = T, additional_vars = NULL)
if ("network" %in% class(net)) {
net <- intergraph::asIgraph(net)
}
# Create nodelist, checking for an "id" column
if (!("id" %in% igraph::vertex_attr_names(net))) {
nodes <- igraph::as_data_frame(net, what = "vertices") %>%
tibble::rownames_to_column(var = "id") %>%
dplyr::mutate(id = as.numeric(id))
} else {
nodes <- igraph::as_data_frame(net, what = "vertices") %>%
dplyr::mutate(id = as.numeric(id))
}
edges <- igraph::as_data_frame(net, what = "edges") %>%
dplyr::mutate_at(vars(from, to), as.numeric)
??vars
if (!("id" %in% igraph::vertex_attr_names(net))) {
nodes <- igraph::as_data_frame(net, what = "vertices") %>%
tibble::rownames_to_column(var = "id") %>%
dplyr::mutate(id = as.numeric(id))
} else {
nodes <- igraph::as_data_frame(net, what = "vertices") %>%
dplyr::mutate(id = as.numeric(id))
}
edges <- igraph::as_data_frame(net, what = "edges") %>%
dplyr::mutate_at(dplyr::vars(from, to), as.numeric)
if (!is.null(additional_vars)) {
vec1 <- nodes$id
# Check if additional_vars was called
if (!is.null(additional_vars)) {
vec1 <- nodes$id
# Check if the called ego df has an id column or a label column
tryCatch(vec2 <- additional_vars$id,
warning = function(e)
tryCatch(vec2 <- additional_vars$label,
warning = function(e)
stop("Make sure your additional ego dataframe contains an id or label variable")))
# Check if the two ids are identical
if (identical(vec1, vec2) == F) {
error_m <- paste0("Make sure the id or label of the additional ego dataframe match model ids exactly.
There are ", length(vec1), " ids in the model and ", length(vec2), " ids in the additional
dataframe, of which ", length(intersect(vec1, vec2)), " intersect.")
stop(error_m)
}
# Merge if all tests are passed
nodes <- nodes %>% dplyr::left_join(additional_vars)
}
# check if there are as many variables as methods
if ((length(variables) == length(methods)) == F) {
stop("Different number of variables and methods")
}
# loop over user defined variables
for (i in 1:length(variables)) {
variable <- variables[i]
method <- methods[i]
# Check (1) if variable in in nodelist (2) if variable NOT in edgelist (3) if transformed variable in edgelist. If False, skip.
if (variable %in% names(nodes) & !(variable %in% names(edges)) & !(!!paste0(variable, "_ego") %in% names(edges))) {
# Add each value with _ego or _alter suffix to edge dataframe
edges <- edges %>%
dplyr::left_join(nodes %>% dplyr::select(id, tidyselect::all_of(variable)), by = c("from" = "id")) %>%
dplyr::rename(!!paste0(variable, "_ego") := variable) %>%
dplyr::left_join(nodes %>% dplyr::select(id, tidyselect::all_of(variable)), by = c("to" = "id")) %>%
dplyr::rename(!!paste0(variable, "_alter") := variable)
# If method "reduced_category", create simple dichotomy
if (method == "reduced_category") {
edges <- edges %>%
dplyr::mutate(!!sym((paste0("same_", variable))) :=
dplyr::case_when(!!sym(paste0(variable, "_alter")) ==
!!sym(paste0(variable, "_ego")) ~ 1,
is.na(!!sym(paste0(variable, "_ego"))) |
is.na(!!sym(paste0(variable, "_alter"))) ~ NA_real_, T ~ 0))
}
# If method "multi_category", create an tidyselect::all_of(variable) for each value and then dichotomize.
if (method == "multi_category") {
opts <- nodes %>% dplyr::select(tidyselect::all_of(variable)) %>% dplyr::distinct() %>% tidyr::drop_na() %>% pull()
for (n in 1:length(opts)) {
edges <- edges %>%
dplyr::mutate(!!sym((paste0("both_", variable, "_", opts[n]))) :=
dplyr::case_when((!!sym(paste0(variable, "_alter")) == opts[n]) &
(!!sym(paste0(variable, "_ego")) == opts[n]) ~ 1,
is.na(!!sym(paste0(variable, "_ego"))) |
is.na(!!sym(paste0(variable, "_alter"))) ~ NA_real_, T ~ 0))
}
}
# If method "difference", take the difference between ego and alter
if (method == "difference") {
edges <- edges %>%
dplyr::mutate(!!sym((paste0("diff_", variable))) :=
as.numeric(!!sym(paste0(variable, "_ego"))) -
as.numeric(!!sym(paste0(variable, "_alter"))))
}
# If diff is "both", run both reduced and multi categories.
if (method == "both") {
edges <- edges %>%
dplyr::mutate(!!sym((paste0("same_", variable))) :=
dplyr::case_when(!!sym(paste0(variable, "_alter")) ==
!!sym(paste0(variable, "_ego")) ~ 1,
is.na(!!sym(paste0(variable, "_ego"))) |
is.na(!!sym(paste0(variable, "_alter"))) ~ NA_real_, T ~ 0))
opts <- nodes %>% dplyr::select(tidyselect::all_of(variable)) %>% dplyr::distinct() %>% tidyr::drop_na() %>% pull()
for (n in 1:length(opts)) {
edges <- edges %>%
dplyr::mutate(!!sym((paste0("both_", variable, "_", opts[n]))) :=
dplyr::case_when((!!sym(paste0(variable, "_alter")) == opts[n]) &
(!!sym(paste0(variable, "_ego")) == opts[n]) ~ 1,
is.na(!!sym(paste0(variable, "_ego"))) |
is.na(!!sym(paste0(variable, "_alter"))) ~ NA_real_, T ~ 0))
}
}
}
}
qap_graph <- igraph::graph_from_data_frame(edges, directed = directed, vertices = nodes)
qap_results <<- list(qap_graph, nodes, edges)
}
qap_setup(net, variables = c("house_gender"), methods = c("reduced_category"),
directed = T, additional_vars = NULL)
qap_setup <- function(net, variables, methods, directed = F, additional_vars = NULL) {
# require(sna)
# require(igraph)
# require(intergraph)
# require(tidygraph)
# require(dplyr)
require(magrittr)
### CONSTRUCTING NODE AND EDGE LISTS ###
# Make sure it's an igraph object
if ("network" %in% class(net)) {
net <- intergraph::asIgraph(net)
}
# Create nodelist, checking for an "id" column
if (!("id" %in% igraph::vertex_attr_names(net))) {
nodes <- igraph::as_data_frame(net, what = "vertices") %>%
tibble::rownames_to_column(var = "id") %>%
dplyr::mutate(id = as.numeric(id))
} else {
nodes <- igraph::as_data_frame(net, what = "vertices") %>%
dplyr::mutate(id = as.numeric(id))
}
# Create edgelist
edges <- igraph::as_data_frame(net, what = "edges") %>%
dplyr::mutate_at(dplyr::vars(from, to), as.numeric)
# Check if additional_vars was called
if (!is.null(additional_vars)) {
vec1 <- nodes$id
# Check if the called ego df has an id column or a label column
tryCatch(vec2 <- additional_vars$id,
warning = function(e)
tryCatch(vec2 <- additional_vars$label,
warning = function(e)
stop("Make sure your additional ego dataframe contains an id or label variable")))
# Check if the two ids are identical
if (identical(vec1, vec2) == F) {
error_m <- paste0("Make sure the id or label of the additional ego dataframe match model ids exactly.
There are ", length(vec1), " ids in the model and ", length(vec2), " ids in the additional
dataframe, of which ", length(intersect(vec1, vec2)), " intersect.")
stop(error_m)
}
# Merge if all tests are passed
nodes <- nodes %>% dplyr::left_join(additional_vars)
}
### CONSTRUCTING DYAD MEASURES FROM EGO MEASURES ###
# check if there are as many variables as methods
if ((length(variables) == length(methods)) == F) {
stop("Different number of variables and methods")
}
# loop over user defined variables
for (i in 1:length(variables)) {
variable <- variables[i]
method <- methods[i]
# Check (1) if variable in in nodelist (2) if variable NOT in edgelist (3) if transformed variable in edgelist. If False, skip.
if (variable %in% names(nodes) & !(variable %in% names(edges)) & !(!!paste0(variable, "_ego") %in% names(edges))) {
# Add each value with _ego or _alter suffix to edge dataframe
edges <- edges %>%
dplyr::left_join(nodes %>% dplyr::select(id, tidyselect::all_of(variable)), by = c("from" = "id")) %>%
dplyr::rename(!!paste0(variable, "_ego") := variable) %>%
dplyr::left_join(nodes %>% dplyr::select(id, tidyselect::all_of(variable)), by = c("to" = "id")) %>%
dplyr::rename(!!paste0(variable, "_alter") := variable)
# If method "reduced_category", create simple dichotomy
if (method == "reduced_category") {
edges <- edges %>%
dplyr::mutate(!!sym((paste0("same_", variable))) :=
dplyr::case_when(!!sym(paste0(variable, "_alter")) ==
!!sym(paste0(variable, "_ego")) ~ 1,
is.na(!!sym(paste0(variable, "_ego"))) |
is.na(!!sym(paste0(variable, "_alter"))) ~ NA_real_, T ~ 0))
}
# If method "multi_category", create an tidyselect::all_of(variable) for each value and then dichotomize.
if (method == "multi_category") {
opts <- nodes %>% dplyr::select(tidyselect::all_of(variable)) %>% dplyr::distinct() %>% tidyr::drop_na() %>% pull()
for (n in 1:length(opts)) {
edges <- edges %>%
dplyr::mutate(!!sym((paste0("both_", variable, "_", opts[n]))) :=
dplyr::case_when((!!sym(paste0(variable, "_alter")) == opts[n]) &
(!!sym(paste0(variable, "_ego")) == opts[n]) ~ 1,
is.na(!!sym(paste0(variable, "_ego"))) |
is.na(!!sym(paste0(variable, "_alter"))) ~ NA_real_, T ~ 0))
}
}
# If method "difference", take the difference between ego and alter
if (method == "difference") {
edges <- edges %>%
dplyr::mutate(!!sym((paste0("diff_", variable))) :=
as.numeric(!!sym(paste0(variable, "_ego"))) -
as.numeric(!!sym(paste0(variable, "_alter"))))
}
# If diff is "both", run both reduced and multi categories.
if (method == "both") {
edges <- edges %>%
dplyr::mutate(!!sym((paste0("same_", variable))) :=
dplyr::case_when(!!sym(paste0(variable, "_alter")) ==
!!sym(paste0(variable, "_ego")) ~ 1,
is.na(!!sym(paste0(variable, "_ego"))) |
is.na(!!sym(paste0(variable, "_alter"))) ~ NA_real_, T ~ 0))
opts <- nodes %>% dplyr::select(tidyselect::all_of(variable)) %>% dplyr::distinct() %>% tidyr::drop_na() %>% pull()
for (n in 1:length(opts)) {
edges <- edges %>%
dplyr::mutate(!!sym((paste0("both_", variable, "_", opts[n]))) :=
dplyr::case_when((!!sym(paste0(variable, "_alter")) == opts[n]) &
(!!sym(paste0(variable, "_ego")) == opts[n]) ~ 1,
is.na(!!sym(paste0(variable, "_ego"))) |
is.na(!!sym(paste0(variable, "_alter"))) ~ NA_real_, T ~ 0))
}
}
}
}
qap_graph <- igraph::graph_from_data_frame(edges, directed = directed, vertices = nodes)
qap_results <<- list(qap_graph, nodes, edges)
}
qap_setup(net, variables = c("house_gender"), methods = c("reduced_category"),
directed = T, additional_vars = NULL)
??netlogit
net
net <- readRDS("/Users/gabe/test.rds")
qap_run(net, dependent = NULL, variables = c("out_degree"), directed = T, family = "linear")
qap_run <- function(net, dependent = NULL, variables, directed = F, family = "linear") {
require(magrittr)
# Make sure it's an igraph object
if ("network" %in% class(net)) {
net <- intergraph::asIgraph(net)
}
# Get DV matrix
if (is.null(dependent)) {
dv <- as.matrix(igraph::as_adjacency_matrix(net))
} else {
dv <- as.matrix(igraph::as_adjacency_matrix(net, attr = dependent))}
# Get IV matrices
ivs <- list()
for (i in 1:length(variables)) {
iv <- variables[[i]]
iv <- as.matrix(igraph::as_adjacency_matrix(net, attr = iv))
ivs[[i]] <- iv
}
# Run QAP
if (directed == T) {mode = "digraph"} else {mode = "graph"}
if (family == "binomial"){
# if (all(dv %in% 0:1) == T){
res <- sna::netlogit(dv, ivs, reps = 10, mode = mode)
} else if (family == "linear") {
res <- sna::netlm(dv, ivs, reps = 100, mode = mode)
} else {print("Not an available family -- Try 'linear' or 'binomial'")}
# Tidy results
variables <- c("intercept", variables)
if (class(res) == "sna::netlogit"){
covs_df <- dplyr::tibble(covars = variables, estimate = res$coefficients,
`exp(estimate)` = exp(res$coefficients), se = res$se,
pvalue = res$pgreqabs)
mods_df <- dplyr::tibble(num_obs = res$n, aic = res$aic, bic = res$bic)
} else {
covs_df <- dplyr::tibble(covars = variables, estimate = res$coefficients,
se = res$se, pvalue = res$pgreqabs)
mods_df <- dplyr::tibble(num_obs = res$n, aic = res$aic, bic = res$bic)
}
model_results <<- list(covs_df, mods_df)
}
qap_run(net, dependent = NULL, variables = c("out_degree"), directed = T, family = "linear")
dependent = NULL
variables = c("out_degree")
directed = T
family = "linear"
require(magrittr)
if ("network" %in% class(net)) {
net <- intergraph::asIgraph(net)
}
if (is.null(dependent)) {
dv <- as.matrix(igraph::as_adjacency_matrix(net))
} else {
dv <- as.matrix(igraph::as_adjacency_matrix(net, attr = dependent))}
# Get IV matrices
ivs <- list()
for (i in 1:length(variables)) {
iv <- variables[[i]]
iv <- as.matrix(igraph::as_adjacency_matrix(net, attr = iv))
ivs[[i]] <- iv
}
variables
i <- 1
variables[[i]]
iv <- variables[[i]]
iv
igraph::as_adjacency_matrix(net, attr = iv)
net
variables = c("weight")
# Get IV matrices
ivs <- list()
for (i in 1:length(variables)) {
iv <- variables[[i]]
iv <- as.matrix(igraph::as_adjacency_matrix(net, attr = iv))
ivs[[i]] <- iv
}
# Run QAP
if (directed == T) {mode = "digraph"} else {mode = "graph"}
if (family == "binomial"){
# if (all(dv %in% 0:1) == T){
res <- sna::netlogit(dv, ivs, reps = 10, mode = mode)
} else if (family == "linear") {
res <- sna::netlm(dv, ivs, reps = 100, mode = mode)
} else {print("Not an available family -- Try 'linear' or 'binomial'")}
# Tidy results
variables <- c("intercept", variables)
if (class(res) == "sna::netlogit"){
covs_df <- dplyr::tibble(covars = variables, estimate = res$coefficients,
`exp(estimate)` = exp(res$coefficients), se = res$se,
pvalue = res$pgreqabs)
mods_df <- dplyr::tibble(num_obs = res$n, aic = res$aic, bic = res$bic)
} else {
covs_df <- dplyr::tibble(covars = variables, estimate = res$coefficients,
se = res$se, pvalue = res$pgreqabs)
mods_df <- dplyr::tibble(num_obs = res$n, aic = res$aic, bic = res$bic)
}
model_results <<- list(covs_df, mods_df)
??which.max
??unlist
?base::unlist
??component_memberships
devtools::install_github("iqss/dataverse-client-r") # Dataverse API
devtools::install_github("https://github.com/Tom-Wolff/ideanet") # IDEANet
devtools::install_github("kieranlele/IDEANETViz") # IDEAnet GUI
library(dataverse)
library(ideanet)
library(IDEANETViz)
library(tidyverse)
library(visNetwork)
Sys.setenv("DATAVERSE_SERVER" = "https://dataverse-test-01.oit.duke.edu")
edges <- get_dataframe_by_name(filename = "edges.tab", dataset = "10.5072/FK2/LIR98P")
nodes <- get_dataframe_by_name(filename = "nodes.tab", dataset = "10.5072/FK2/LIR98P")
edges %>% head()
print(paste0("Total number of distinct edges: ", edges %>% distinct(from, to) %>% nrow()))
print(paste0("Total number of health edges: ", edges %>% filter(tietype == "health") %>% nrow()))
print(paste0("Total number of social edges: ", edges %>% filter(tietype == "social") %>% nrow()))
print(paste0("Total number of edges: ", edges %>% nrow()))
nodes %>% head()
nodes %>% names()
devtools::install_github("iqss/dataverse-client-r") # Dataverse API
devtools::install_github("https://github.com/Tom-Wolff/ideanet") # IDEANet
devtools::install_github("kieranlele/IDEANETViz") # IDEAnet GUI
devtools::install_github("iqss/dataverse-client-r") # Dataverse API
devtools::install_github("https://github.com/Tom-Wolff/ideanet") # IDEANet
devtools::install_github("kieranlele/IDEANETViz") # IDEAnet GUI
library(dataverse)
library(ideanet)
library(IDEANETViz)
library(tidyverse)
library(visNetwork)
Sys.setenv("DATAVERSE_SERVER" = "https://dataverse-test-01.oit.duke.edu")
?ideanet::netwrite()
IDEANETViz::ideanet_viz()
devtools::install_github("iqss/dataverse-client-r") # Dataverse API
devtools::install_github("https://github.com/Tom-Wolff/ideanet") # IDEANet
devtools::install_github("kieranlele/IDEANETViz") # IDEAnet GUI
library(dataverse)
library(ideanet)
library(IDEANETViz)
library(tidyverse)
library(visNetwork)
netread(path = "edges.xlsx",
filetype = "excel",
nodelist = "nodes.xlsx",
col_names = T, row_names = F,
format = "edgelist",
net_name = "village",
i_elements = "to",
j_elements = "from")
ideanet::netwrite(i_elements = edges$from,
j_elements = edges$to, # ties.
nodelist = nodes,
node_id = "id", # vertices.
directed = T, # directedness.
weights = edges$weight, # tie-weights.
type = edges$tietype, #
shiny = FALSE, #disabel shiny functionality
net_name = 'village_net'
) # multiple kinds of relationships.
edges <- get_dataframe_by_name(filename = "edges.tab", dataset = "10.5072/FK2/LIR98P")
Sys.setenv("DATAVERSE_SERVER" = "https://dataverse-test-01.oit.duke.edu")
edges <- get_dataframe_by_name(filename = "edges.tab", dataset = "10.5072/FK2/LIR98P")
nodes <- get_dataframe_by_name(filename = "nodes.tab", dataset = "10.5072/FK2/LIR98P")
netread(path = "edges.xlsx",
filetype = "excel",
nodelist = "nodes.xlsx",
col_names = T, row_names = F,
format = "edgelist",
net_name = "village",
i_elements = "to",
j_elements = "from")
ideanet::netwrite(i_elements = edges$from,
j_elements = edges$to, # ties.
nodelist = nodes,
node_id = "id", # vertices.
directed = T, # directedness.
weights = edges$weight, # tie-weights.
type = edges$tietype, #
shiny = FALSE, #disabel shiny functionality
net_name = 'village_net'
) # multiple kinds of relationships.
ideanet::communities(g = village_net)
head(comm_members_net)
comm_members_net$id <- as.double(comm_members_net$id)
node_measures_communities <- node_measures %>% left_join(comm_members_net, by = 'id')
ideanet::role_analysis(graph = village_net,
nodes = node_measures,
directed = TRUE,
method = 'cluster',
min_partitions = 2,
max_partitions = 7,
viz = TRUE,
min_partition_size = 5)
node_measures_roles <- node_measures %>% left_join(cluster_assignments, by = 'id')
V(village_net)$color = node_measures_roles$best_fit
V(village_net)$size = node_measures_roles$total_degree
vis_net <- toVisNetworkData(village_net)
visNetwork(vis_net$nodes, vis_net$edges) %>% visIgraphLayout('layout_with_fr')
V(village_net)$color = node_measures_roles$best_fit
V(village_net)$size = (node_measures_roles$total_degree * 5)
vis_net <- toVisNetworkData(village_net)
visNetwork(vis_net$nodes, vis_net$edges) %>% visIgraphLayout('layout_with_fr')
m <- lm(health ~ house_caste + house_gender + adultmems + # traditional covariates
social_total_degree + health_weighted_indegree + # degree covariates
betweenness + eigen_centrality, # centrality in the network
data = node_measures)
dotwhisker::dwplot(m) +
geom_vline(xintercept = 0, color = "grey60", linetype = 2) +
ggtitle("Associations with self-reported health") +
labs(x = "", y = "", col = "Outcome") +
theme_bw()
IDEANETViz::ideanet_viz()
devtools::install_github("iqss/dataverse-client-r") # Dataverse API
devtools::install_github("https://github.com/Tom-Wolff/ideanet") # IDEANet
devtools::install_github("kieranlele/IDEANETViz") # IDEAnet GUI
library(dataverse)
library(ideanet)
library(IDEANETViz)
library(tidyverse)
library(visNetwork)
edges <- get_dataframe_by_name(filename = "edges.tab", dataset = "10.5072/FK2/LIR98P")
nodes <- get_dataframe_by_name(filename = "nodes.tab", dataset = "10.5072/FK2/LIR98P")
edges %>% head()
print(paste0("Total number of distinct edges: ", edges %>% distinct(from, to) %>% nrow()))
print(paste0("Total number of health edges: ", edges %>% filter(tietype == "health") %>% nrow()))
print(paste0("Total number of social edges: ", edges %>% filter(tietype == "social") %>% nrow()))
print(paste0("Total number of edges: ", edges %>% nrow()))
nodes %>% head()
nodes %>% names()
?ideanet::netread()
netread(path = "edges.xlsx",
filetype = "excel",
nodelist = "nodes.xlsx",
col_names = T, row_names = F,
format = "edgelist",
net_name = "village",
i_elements = "to",
j_elements = "from")
?ideanet::netwrite()
ideanet::netwrite(i_elements = edges$from,
j_elements = edges$to, # ties.
nodelist = nodes,
node_id = "id", # vertices.
directed = T, # directedness.
weights = edges$weight, # tie-weights.
type = edges$tietype, #
shiny = FALSE, #disabel shiny functionality
net_name = 'village_net'
) # multiple kinds of relationships.
head(node_measures)
node_measures %>% names()
largest_component
plot(node_measure_plot)
plot(system_measure_plot)
node_measures %>% pull(eigen_centrality) %>% summary()
ideanet::communities(g = village_net)
head(comm_members_net)
comm_members_net %>% names()
comm_members_net$id <- as.double(comm_members_net$id)
node_measures_communities <- node_measures %>% left_join(comm_members_net, by = 'id')
node_measures_roles <- node_measures %>% left_join(cluster_assignments, by = 'id')
plot(cluster_relations_heatmaps$chisq)
plot(cluster_summaries_cent$summary_graph)
V(village_net)$color = node_measures_roles$best_fit
V(village_net)$size = (node_measures_roles$total_degree * 5)
vis_net <- toVisNetworkData(village_net)
visNetwork(vis_net$nodes, vis_net$edges) %>% visIgraphLayout('layout_with_fr')
m <- lm(health ~ house_caste + house_gender + adultmems + # traditional covariates
social_total_degree + health_weighted_indegree + # degree covariates
betweenness + eigen_centrality, # centrality in the network
data = node_measures)
dotwhisker::dwplot(m) +
geom_vline(xintercept = 0, color = "grey60", linetype = 2) +
ggtitle("Associations with self-reported health") +
labs(x = "", y = "", col = "Outcome") +
theme_bw()
IDEANETViz::ideanet_viz()
