plot(g)
plot(g_undir)
# Get reciprocal of edge weight for algorithms that treat edge weights as distances
igraph::E(g_undir)$r_weight <- 1/igraph::E(g_undir)$weight
# Betweenness does edges as distances. Need reciprocal
edge_betweenness <- igraph::cluster_edge_betweenness(g_undir,
weights = igraph::E(g_undir)$r_weight,
directed = FALSE,
membership = T,
modularity = T)
fast_greedy <- igraph::cluster_fast_greedy(g_undir,
weights = igraph::E(g_undir)$weight) # Only undirected graphs
infomap <- igraph::cluster_infomap(g_undir,
e.weights = igraph::E(g_undir)$weight) # Modularity for undirected graphs only
label_prop <- igraph::cluster_label_prop(g_undir,
weights = igraph::E(g_undir)$weight) # Needs to be undirected
leiden_mod <- igraph::cluster_leiden(g_undir,
objective_function = "modularity",
resolution_parameter=modres,
weights = igraph::E(g_undir)$weight,
n_iterations = 300) # Only undirected graphs # Leiden is better version of louvain
leiden_cpm <- igraph::cluster_leiden(g_undir,
objective_function = "CPM",
resolution_parameter = w_dens,
weights = igraph::E(g_undir)$weight,
n_iterations = 300)
modularity(edge_betweenness)
modularity(infomap)
modularity(fast_greedy)
modularity(leiden_cpm)
modularity(g_undir,membership(edge_betweenness)
)
modularity(g_undir,membership(fast_greedy))
?modularity
modularity(g_undir,membership(fast_greedy),weights=E(g_undir)$weight)
modularity(g_undir,membership(edge_betweenness),weights=E(g_undir)$weight)
modularity(edge_betweenness)
modularity(g_undir,membership(edge_betweenness),weights=E(g_undir)$weight,directed=FALSE)
is_simple(g_undir)
is_simple(g)
modularity(g_undir,membership(edge_betweenness),weights=E(g_undir)$weight)
modularity(g,membership(edge_betweenness),weights=E(g)$weight)
modularity(g,membership(edge_betweenness))
?cluster_leiden
modularity(edge_betweenness)
modularity(g,membership(edge_betweenness),weights=E(g)$weight)
modularity(g,membership(edge_betweenness),weights=E(g)$r_weight)
modularity(g_undir,membership(edge_betweenness),weights=E(g_undir)$weight)
modularity(g_undir,membership(edge_betweenness),weights=E(g_undir)$r_weight)
?cluster_edge_betweenness
modularity(g_undir,membership(edge_betweenness),weights=E(g_undir)$weight)
modularity(g_undir,membership(fast_greedy),weights=E(g_undir)$weight)
modularity(g_undir,membership(fast_greedy))
?modularity
modularity(g_undir,membership(fast_greedy),weights=E(g_undir)$weight)
modularity(fast_greedy)
modularity(g_undir,membership(label_prop),weights=E(g_undir)$weight)
modularity(leiden_prop)
modularity(label_prop)
modularity(leiden_mod)
modularity(g_undir,membership(leiden_mod),weights=E(g_undir)$weight)
modularity(g_undir,membership(leiden_cpm),weights=E(g_undir)$weight)
cluster_spinglass(g_undir)
walktrap <- igraph::cluster_walktrap(g_undir,
weights = igraph::E(g_undir)$weight) # Works with directed
# Get number of isolated components
num_components <- igraph::components(g_undir)
num_components
if (num_components$no == 1) {
spinglass <- igraph::cluster_spinglass(g_undir, weights = igraph::E(g_undir)$weight) # Works with directed, but need to ask about arguments (there are many)
leading_eigen <- igraph::cluster_leading_eigen(g_undir, weights = igraph::E(g_undir)$weight) # Needs to be undirected
} else {
igraph::V(g_undir)$component <- num_components$membership
subgraph_memberships <- data.frame()
# Isolate components
for (i in 1:num_components$no) {
this_component <- igraph::delete.vertices(g_undir, v = (igraph::V(g_undir)$component != i))
if (length(igraph::V(this_component)) <= 5) {
component_sums <- data.frame(id = as.numeric(names(igraph::V(this_component))),
component = i,
leading_eigen_membership = NA,
spinglass_membership = NA)
subgraph_memberships <- rbind(subgraph_memberships, component_sums)
} else {
this_leading_eigen <- igraph::cluster_leading_eigen(this_component,
weights = igraph::E(this_component)$weight)$membership
this_spinglass <- igraph::cluster_spinglass(this_component,
weights = igraph::E(this_component)$weight)$membership # Works with directed, but need to ask about arguments (there are many)
component_sums <- data.frame(id = as.numeric(names(igraph::V(this_component))),
component = i,
leading_eigen_membership = this_leading_eigen,
spinglass_membership = this_spinglass)
subgraph_memberships <- rbind(subgraph_memberships, component_sums)
}
}
# Assign new unique membership IDs. This is because, as it currently stands, each component
# has membership ids 1-n, which are redundant labels across several components
subgraph_memberships$leading_eigen_paste <- paste(subgraph_memberships$component, subgraph_memberships$leading_eigen_membership, sep = "_")
subgraph_memberships$spinglass_paste <- paste(subgraph_memberships$component, subgraph_memberships$spinglass_membership, sep = "_")
leading_eigen_ids <- data.frame(leading_eigen_paste = unique(subgraph_memberships$leading_eigen_paste),
new_leading_eigen = 1:length(unique(subgraph_memberships$leading_eigen_paste)))
spinglass_ids <- data.frame(spinglass_paste = unique(subgraph_memberships$spinglass_paste),
new_spinglass = 1:length(unique(subgraph_memberships$spinglass_paste)))
subgraph_memberships <- dplyr::left_join(subgraph_memberships, leading_eigen_ids, by = "leading_eigen_paste")
subgraph_memberships <- dplyr::left_join(subgraph_memberships, spinglass_ids, by = "spinglass_paste")
# subgraph_memberships$new_leading_eigen <- ifelse(is.na(subgraph_memberships$leading_eigen_membership),
#                                                  0,
#                                                  subgraph_memberships$new_leading_eigen)
#
# subgraph_memberships$new_spinglass <- ifelse(is.na(subgraph_memberships$spinglass_membership),
#                                                  0,
#                                                  subgraph_memberships$new_spinglass)
subgraph_memberships <- subgraph_memberships[, c("id", "component", "new_leading_eigen", "new_spinglass")]
colnames(subgraph_memberships) <- c("id", "component", "leading_eigen_membership", "spinglass_membership")
}
g
comm_detect(g)
setwd("~/GitHub/ideanet/R")
comm_detect(g)
source("community_detection.R")
comm_detect(g)
comm_detect(g)
g
comm_detect(florentine)
fast_greedy
membership(fast_greedy)
memberships
fc<-comm_detect(florentine)
fc$memberships
fc$summaries
fc<-comm_detect(florentine)
fc$summaries
modularity(g_undir,membership(leiden_cpm),weights=E(g_undir)$weight)
fc
fc$memberships
fc$memberships$edge_betweenness_membership
modularity(g_undir,fc$memberships$edge_betweenness_membership)
modularity(g_undir,fc$memberships$edge_betweenness_membership,E(g_undir)$weight)
modularity(g_undir,fc$memberships$edge_betweenness_membership,weights=E(g_undir)$weight)
fc$summaries
modularity(edge_betweenness)
modularity(g_undir,fc$memberships$edge_betweenness_membership,weights=E(g_undir)$weight)
modularity(fast_greedy)
modularity(g_undir,fc$memberships$fast_greedy_membership,weights=E(g_undir)$weight)
modularity(infomap)
modularity(label_prop)
modularity(g_undir,fc$memberships$label_prop_membership,weights=E(g_undir)$weight)
modularity(g_undir,fc$memberships$leading_eigen_membership,weights=E(g_undir)$weight)
modularity(g_undir,fc$memberships$leading_eigen_membership)
E(g_undir)$weight
?cluster_edge_betweenness
fc$memberships$leading_eigen_membership
?modularity
cluster_leading_eigen(karate)
cluster_leading_eigen(karate)
karate
modularity(karate,cluster_leading_eigen(karate))
modularity(karate,membership(cluster_leading_eigen(karate)))
modularity(karate,membership(cluster_leading_eigen(karate)),weights=E(karate)$weight)
modularity(cluster_leading_eigen(karate))
modularity(karate,membership(cluster_leading_eigen(karate)),weights=E(karate)$weight)
fc<comm_detect(florentine)
fc$summaries
source("community_detection.R")
fc<comm_detect(florentine)
fc$summaries
source("community_detection.R")
fc<-comm_detect(florentine)
fc$summaries
modularity(fc$memberships$label_prop_membership)
modularity(g_undir,fc$memberships$label_prop_membership,weights=E(g_undir)$weight)
modularity(g_undir,fc$memberships$leading_eigen_membership,weights=E(g_undir)$weight)
modularity(g_undir,fc$memberships$leiden_mod_membership,weights=E(g_undir)$weight)
modularity(g_undir,fc$memberships$leiden_mod_membership)
modularity(g_undir,fc$memberships$fast_greedy_membership,weights=E(g_undir)$weight)
modularity(g_undir,fc$memberships$leiden_mod_membership,weights=E(g_undir)$weight)
modularity(g_undir,fc$memberships$leiden_cpm_membership,weights=E(g_undir)$weight)
fc<-comm_detect(florentine)
fc$summaries
source("community_detection.R")
source("community_detection.R")
source("community_detection.R")
fc<-comm_detect(florentine)
fc$summaries
modularity(g_undir,fc$memberships$walktrap_membership,weights=E(g_undir)$weight)
modularity(g_undir,fc$memberships$spinglass_membership,weights=E(g_undir)$weight)
source("comm")
source("community_detection.R
")"
source("community_detection.R")
fc<-comm_detect(florentine)
max(E(g)$weight)
mode(E(g)$weight)
?cluster_leiden
source("community_detection.R")
fc<-comm_detect(florentine)
fc$summaries
modularity(g_undir,fc$memberships$walktrap_membership,weights=E(g_undir)$weight)
modularity(g_undir,fc$memberships$sbm_membership,weights=E(g_undir)$weight)
plot(florentine)
plot(g_undir)
plot(fc$memberships$sbm_membership,g_undir)
plot(g_undir,fc$memberships$sbm_membership)
library(ideanet)
source("community_detection.R")
fc<-florentine
head(florentine_edges)
library(ideanet)
fauxmesa_edges <- fauxmesa_edges
fauxmesa_nodes <- fauxmesa_nodes
knitr::kable(head(florentine_edges, n = 10))
nw_flor <- netwrite(nodelist = florentine_nodes,
node_id = "id",
i_elements = florentine_edges$source,
j_elements = florentine_edges$target,
type = florentine_edges$type,
directed = FALSE,
net_name = "florentine")
list2env(nw_flor, .GlobalEnv)
head(edgelist$business)
knitr::kable(head(edgelist$business))
head(edgelist$summary_graph)
knitr::kable(head(edgelist$summary_graph))
knitr::kable(node_measures %>%
dplyr::select(id, total_degree, marriage_total_degree, business_total_degree) %>%
head())
head(system_level_measures)
knitr::kable(head(system_level_measures))
par(mfrow = c(1, 2), mar = c(1, 1, 1, 1))
# Create a consistent layout for both plots
flor_layout <- igraph::layout.fruchterman.reingold(igraph_list$marriage)
plot(igraph_list$marriage, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "gray", main = "Marriage Network", layout = flor_layout)
plot(igraph_list$business, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "red", main = "Business Network", layout = flor_layout)
flor_communities <- comm_detect(florentine)
source("community_detection.R")
flor_communities <- comm_detect(florentine)
flor_communities <- comm_detect(florentine)
source("community_detection.R")
flor_communities <- comm_detect(florentine)
flor_communities$summaries
knitr::kable(flor_communities$summaries)
flor_communities$score_comparison
??netwrite
vignette("netwrite","ideanet")
g_sym <- as.matrix(igraph::as_adjacency_matrix(g_undir, attr = "weight"))
g_sym <- as.matrix(igraph::as_adjacency_matrix(karate, attr = "weight"))
data(karate)
library(igraph)
data(karate)
library(igraphdata)
data(karate)
g_sym <- as.matrix(igraph::as_adjacency_matrix(karate, attr = "weight"))
g_sym
as_adjacency_matrix(karate)
?as.matrix
E(karate)
E(karate)$weight
var(E(karate)$weight)
var(c(1,1,1,1,1))
cluster_edge_betweenness(karate)
getwd()
devtools::load_all("..")
?get_partitions
library(igraphdata)
data(karate)
partitions <- get_partitions(karate, n_runs = 2500)
library(igraphdata)
data(karate)
partitions <- get_partitions(karate, n_runs = 2500)
devtools::load_all("..")
library(igraphdata)
data(karate)
partitions <- get_partitions(karate, n_runs = 2500)
devtools::load_all("..")
data(karate)
partitions <- get_partitions(karate, n_runs = 2500)
??compare
devtools::load_all("..")
partitions <- get_partitions(karate, n_runs = 2500)
devtools::load_all("..")
partitions <- get_partitions(karate, n_runs = 2500)
partitions <- get_partitions(karate, n_runs = 2500)
partitions <- get_partitions(karate, n_runs = 2500)
devtools::install_github("Tom-Wolff/ideanet@add_champ", build_vignettes = TRUE, force=TRUE)
?get_partitions
library(ideanet)
?get_partitions
?get_partitions
?glmnet
?glmnet::glmnet
?glmnet::cv.glmnet
?load_all
?glmnet::cv.glmnet
?glmnet::glmnet
?CVXR::solve
?CVXR::p_norm
?CVXR::logistic
?CVXR::Problem
problem
getwd()
setwd("~/Documents/GitHub/compositional-regularization/R")
cdiff <- read_csv("../Data/170908_Cdiff_trios_export_fixed_JIR_SAMPLES_ONLY.csv")
library(tidyverse)
cdiff <- read_csv("../Data/170908_Cdiff_trios_export_fixed_JIR_SAMPLES_ONLY.csv")
cdiffkey <- read_csv("../Data/Cdiff-trios-sample-key-170907_SAMPLES_ONLY.csv")
all(colnames(cdiff[,-1:-4]) == cdiffkey$`File Name`)
x <- t(as.matrix(log10(cdiff[,-1:-4])))
missingrows <- is.na(rowSums(x))
x <- x[!missingrows,]
colnames(x) <- cdiff$Compound
minappearances <- 20
keeperfeatures <- (colSums(is.finite(x)) >= minappearances)
x <- x[,keeperfeatures]
x[is.infinite(x)] <- min(x[is.finite(x)])
yEIA <- cdiffkey$Cdiff_EIA[!missingrows]
yCulture <- cdiffkey$Tox_Culture[!missingrows]
intersect(yEIA,yCulture)
yEIA <- yEIA=="positive"
yCulture <- yCulture=="positive"
keepers <- (yEIA & yCulture) | ((!yEIA) & (!yCulture))
X <- x[keepers,]
Y <- as.numeric((yEIA & yCulture)[keepers])
hist(colSums(X>min(x)), breaks = 0:nrow(X))
set.seed(321)
lambda <- 0.1
thresh <- 1e-12
kappa <- 0.1
n <- nrow(X)
p <- ncol(X)
XDesign <- cbind(1,X) #To include intercept
beta <- Variable(p + 1)
library(CVXR)
set.seed(321)
lambda <- 0.1
thresh <- 1e-12
kappa <- 0.1
n <- nrow(X)
p <- ncol(X)
XDesign <- cbind(1,X) #To include intercept
beta <- Variable(p + 1)
sigma <- sqrt((n-1)/n) * sapply(data.frame(X),sd) #sd uses denominator n-1
obj <- (sum(XDesign[Y <= 0, ] %*% beta) + sum(logistic(-XDesign %*% beta))) / n +
lambda * p_norm(beta[-1]*sigma, 1) + kappa * abs(sum(beta[-1]))
prob <- Problem(Minimize(obj))
result <- solve(prob, FEASTOL = thresh, RELTOL = thresh, ABSTOL = thresh)
sum(betas)
intercept
casper(X,Y,lamba=0.1,kappa=0.1)
getwd()
source('casper.R')
casper(X,Y,lamba=0.1,kappa=0.1)
casper(X,Y)
casper(X,Y)
fit<-casper(X,Y)
fit<-casper(X,Y)
source('casper.R')
fit<-casper(X,Y)
casper(X,Y,lambda=0.1,kappa=0.1)
casper(X,Y,lambda=0.1,kappa=0.1)
source('casper.R')
casper(X,Y,lambda=0.1,kappa=0.1)
source('casper.R')
source('casper.R')
casper(X,Y,lambda=0.1,kappa=0.1)
source('casper.R')
casper(X,Y,lambda=0.1,kappa=0.1)
n <- nrow(X)
p <- ncol(X)
sigma <- sqrt((n-1)/n) * sapply(data.frame(X),sd) #sd uses denominator n-1
#In lieu of standardizing the features, we rescale the L1 term by sigma so that the kappa=0 case matches the results of \code{glmnet(X, Y, lambda = lambda, thresh = thresh, family = "binomial")}
XDesign <- cbind(1,X) #To include intercept in model
beta <- Variable(p + 1)
objective <- (sum(XDesign[Y <= 0, ] %*% beta) + sum(logistic(-XDesign %*% beta))) / n +
lambda * p_norm(beta[-1]*sigma, 1) + kappa * abs(sum(beta[-1]))
problem <- CVXR::Problem(CVXR::Minimize(objective))
result <- CVXR::solve(problem, FEASTOL = thresh, RELTOL = thresh, ABSTOL = thresh)
beta <- result$getValue(beta)
intercept <- beta[1]
beta <- beta[-1]
rownames(beta)
colnames(X)
rownames(beta) <- c(colnames(X))
intercept
betas <- result$getValue(beta)
beta <- Variable(p + 1)
objective <- (sum(XDesign[Y <= 0, ] %*% beta) + sum(logistic(-XDesign %*% beta))) / n +
lambda * p_norm(beta[-1]*sigma, 1) + kappa * abs(sum(beta[-1]))
problem <- CVXR::Problem(CVXR::Minimize(objective))
result <- CVXR::solve(problem, FEASTOL = thresh, RELTOL = thresh, ABSTOL = thresh)
beta <- result$getValue(beta)
rownames(betas) <- c("(Intercept)",colnames(X))
rownames(beta) <- c("(Intercept)",colnames(X))
beta <- beta[-1]
beta
rownames(beta)
beta <- result$getValue(beta)
beta <- Variable(p + 1)
objective <- (sum(XDesign[Y <= 0, ] %*% beta) + sum(logistic(-XDesign %*% beta))) / n +
lambda * p_norm(beta[-1]*sigma, 1) + kappa * abs(sum(beta[-1]))
problem <- CVXR::Problem(CVXR::Minimize(objective))
result <- CVXR::solve(problem, FEASTOL = thresh, RELTOL = thresh, ABSTOL = thresh)
beta <- result$getValue(beta)
intercept <- beta[1]
beta <- beta[-1]
beta <- Variable(p + 1)
objective <- (sum(XDesign[Y <= 0, ] %*% beta) + sum(logistic(-XDesign %*% beta))) / n +
lambda * p_norm(beta[-1]*sigma, 1) + kappa * abs(sum(beta[-1]))
problem <- CVXR::Problem(CVXR::Minimize(objective))
result <- CVXR::solve(problem, FEASTOL = thresh, RELTOL = thresh, ABSTOL = thresh)
beta <- result$getValue(beta)
intercept <- beta[1]
beta <- beta[-1,]
beta <- Variable(p + 1)
objective <- (sum(XDesign[Y <= 0, ] %*% beta) + sum(logistic(-XDesign %*% beta))) / n +
lambda * p_norm(beta[-1]*sigma, 1) + kappa * abs(sum(beta[-1]))
problem <- CVXR::Problem(CVXR::Minimize(objective))
result <- CVXR::solve(problem, FEASTOL = thresh, RELTOL = thresh, ABSTOL = thresh)
betas <- result$getValue(beta)
rownames(betas) <- c("(Intercept)",colnames(X))
colnames(betas)
rownames(betas)
betas <- result$getValue(beta)
rownames(betas) <- c("(Intercept)",colnames(X))
beta2 <- betas[-1,]
colnames(beta2)
rownames(beta2)
source('casper.R')
casper(X,Y,lamba=0.1,kappa=0.1)
casper(X,Y,lambda=0.1,kappa=0.1)
?as.data.frame
source('casper.R')
casper(X,Y,lambda=0.1,kappa=0.1)
source('casper.R')
casper(X,Y,lambda=0.1,kappa=0.1)
fit<-casper(X,Y,lambda=0.1,kappa=0.1)
fit$lambda
source('casper.R')
fit<-casper(X,Y,lambda=0.1,kappa=0.1)
fit$beta
fit$intercept
source('casper.R')
fit<-casper(X,Y,lambda=0.1,kappa=0.1)
fit$lambda
fit$intercept
rownames(fit$beta)
getwd()
setwd("~/Documents/GitHub/ideanet")
roxygen2::roxygenise(package.dir = ".")
?CHAMP
?CHAMP
roxygen2::roxygenise(package.dir = ".")
?CHAMP
roxygen2::roxygenise(package.dir = ".")
?CHAMP
devtools::load_all()
?igraph::modularity
?igraph::cluster_leiden
?igraph::is_directed
?igraph::cluster_leiden
library(igraphdata)
data(karate)
karate
?igraph::modularity
t <- igraph::erdos.renyi.game(5,10)
t <- igraph::erdos.renyi.game(10,0.2)
t
E(t)
igraph::E(t)
igraph::E(t)$weight
c <- igraph::cluster_leiden(t)
c
c <- igraph::cluster_leiden(t,objective_function = "modularity")
c
igraph::modularity(t,membership(c),weights=E(t)$weight)
igraph::modularity(t,igraph::membership(c),weights=E(t)$weight)
igraph::modularity(t,igraph::membership(c),weights=igraph::E(t)$weight)
igraph::E(t)$weight
roxygen2::roxygenise(package.dir = ".")
roxygen2::roxygenise(package.dir = ".")
roxygen2::roxygenise(package.dir = ".")
?CHAMP
devtools::install_github("Tom-Wolff/ideanet@add_champ", build_vignettes = TRUE, force=TRUE)
library(ideanet)
?CHAMP
library(ideanet)
?get_partitions
library(ideanet)
?get_partitions
?CHAMP
roxygen2::roxygenise(package.dir = ".")
?CHAMP
devtools::install_github("Tom-Wolff/ideanet@add_champ", build_vignettes = TRUE, force=TRUE)
library(ideanet)
?get_partitions
?CHAMP
partitions <- get_partitions(karate, n_runs = 2500)
partition_summary <- CHAMP(karate,partitions,plottitle="Weighted Karate Club")
partition_summary <- CHAMP(karate,partitions,plottitle="Weighted Karate Club")
load_all()
devtools::load_all()
partition_summary <- CHAMP(karate,partitions,plottitle="Weighted Karate Club")
partition_summary
# library(xcms)
library(diffCompVarRcpp)
devtools::install_git("andrew84830813/diffCompVarRcpp")
devtools::install_github("andrew84830813/diffCompVarRcpp")
devtools::install_github("andrew84830813/diffCompVarRcpp")
devtools::install_github("andrew84830813/diffCompVarRcpp")
devtools::install_github("andrew84830813/diffCompVarRcpp")
devtools::install_github("andrew84830813/diffCompVarRcpp")
